{"meta":{"title":"jack二虫虫","subtitle":"jack二虫虫","description":"永远对自己的职业保持敬畏之心，谦逊好奇，努力修炼","author":"潘腾龙","url":"https://jackerchongchong.github.io","root":"/"},"pages":[{"title":"","date":"2021-05-19T02:06:41.475Z","updated":"2019-08-20T03:02:02.000Z","comments":true,"path":"baidu_verify_ZfX3kuBFMU.html","permalink":"https://jackerchongchong.github.io/baidu_verify_ZfX3kuBFMU.html","excerpt":"","text":"ZfX3kuBFMU"},{"title":"categories","date":"2019-07-31T03:36:12.000Z","updated":"2019-07-31T03:36:49.000Z","comments":true,"path":"categories/index.html","permalink":"https://jackerchongchong.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-07-31T03:37:38.000Z","updated":"2019-09-09T05:42:42.000Z","comments":true,"path":"about/index.html","permalink":"https://jackerchongchong.github.io/about/index.html","excerpt":"","text":"待完善。。。"},{"title":"contact","date":"2019-09-06T03:59:30.000Z","updated":"2019-09-09T05:41:23.000Z","comments":true,"path":"contact/index.html","permalink":"https://jackerchongchong.github.io/contact/index.html","excerpt":"","text":"在这里可以畅所欲言，欢迎大家提出宝贵的意见对于写的文章，如有错误和新的见解，欢迎留言。共同探讨，共同进步。如果有搭建博客相关的问题，或者有一些改进的地方。也欢迎提问，从博客搭建到最后百度SEO搜索引擎优化，中间踩了不少坑，需要的可以跟大家分享一下。 我的博客地址： Jack二虫虫也可以加QQ沟通： 825473280@qq.com"},{"title":"tags","date":"2019-07-31T03:37:05.000Z","updated":"2019-08-09T02:11:08.000Z","comments":true,"path":"tags/index.html","permalink":"https://jackerchongchong.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-07-31T03:38:14.000Z","updated":"2019-07-31T03:39:34.000Z","comments":true,"path":"friends/index.html","permalink":"https://jackerchongchong.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"关于UIimage存储以及显示的问题","slug":"iosBase5","date":"2020-05-09T09:10:55.000Z","updated":"2020-05-09T09:35:20.210Z","comments":true,"path":"2020/05/09/iosbase5/","link":"","permalink":"https://jackerchongchong.github.io/2020/05/09/iosbase5/","excerpt":"","text":"关于UIImage存储的那些事最近在做一款APP时，需要存储以及加载大量的本地图片，在写代码过程中，遇到一些问题，导致内存暴涨，导致cash. 将拍摄或者从相册选取的图片存入沙盒/// 将图片保存到本地 + (void)saveImageToLocal:(UIImage*)image fileName:(NSString*)fileName { NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; NSString *filePath = [documentPath stringByAppendingPathComponent:[NSString stringWithFormat:@\"%@.png\", fileName]]; // 图片转base64字符串 NSData *data = UIImageJPEGRepresentation(image, 1.0); // 写入文件 BOOL flag = [data writeToFile:filePath atomically:YES]; if (flag) { NSLog(@\"保存成功\"); } } 由于图片不能被压缩，要保证图片不失帧，所以用到了苹果官方提供的方法 UIImageJPEGRepresentation(image, 1.0)这个方法，会在不失帧的情况下，将图片转化成data二进制流。由于此方法比较耗时，所以，尽量减少在循环中大量调用此方法。存储时，最好直接将图片写入沙盒。不要做多余的转化 显示的时候，直接从沙盒读取，直接读取图片，不要再用 [UIimage imageWithData:data] 来再次转化，因为此方法，会使你的内存得不到释放，且，由于是系统提供的方法，在ARC环境下，不能手动释放。 可能有人会说，加一个@autoreleasepool {}自动释放池，但是并不能及时的释放掉，创建的Data或者image，即使是加了 data = nil image = nil 也不能正确的释放掉，已经创建好的对象。 所以，取图片时，也必须直接取出 /// 从本地获取图片 + (UIImage*)getImageFromLocal:(NSString*)fileName { NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; NSString *filePath = [documentPath stringByAppendingPathComponent:[NSString stringWithFormat:@\"%@.png\", fileName]]; UIImage *image = [UIImage imageWithContentsOfFile:filePath]; return image; } 尽可能的减少对 [UIimage imageWithData:data] 的使用。因为加载图片时，内存不会飙升到手机的内存限制，但是如果多次使用以上两个耗时方法，会因为对象的使用内存无法得到及时的释放，从而累加，直至超出手机的限制，从而导致程序闪退。 以上是对遇到此问题的一个笔记，仅供参考，欢迎讨论。","categories":[{"name":"iOS基础知识总结","slug":"iOS基础知识总结","permalink":"https://jackerchongchong.github.io/categories/iOS基础知识总结/"}],"tags":[{"name":"iOS基础知识总结","slug":"iOS基础知识总结","permalink":"https://jackerchongchong.github.io/tags/iOS基础知识总结/"}]},{"title":"高德地图的使用","slug":"iosBaseX4","date":"2020-01-06T16:11:55.000Z","updated":"2020-01-06T16:18:41.250Z","comments":true,"path":"2020/01/07/iosbasex4/","link":"","permalink":"https://jackerchongchong.github.io/2020/01/07/iosbasex4/","excerpt":"","text":"关于高德地图的使用最近在做一款iOS APP，用到了地图功能，出于多方考虑，使用了高德地图，来实现，实时轨迹、轨迹循迹、在地图上显示自定义大头针，轨迹平滑处理、加载高德地图瓦片功能等，在这里做一下总结。 地图初始化 首先，根据高德开发文档，将SDK导入到项目中，这里不做赘述 导入成功后，在.h文件中引入头文件： import AMapFoundationKit/AMapFoundationKit.h import MAMapKit/MAMapKit.h import AMapLocationKit/AMapLocationManager.h 初始化地图： 设置属性 // 高德地图 @property (nonatomic, strong) MAMapView *mapView; // 定位管理者 @property (nonatomic, strong) AMapLocationManager *locationManager; // 地图瓦片 @property (nonatomic, strong) MATileOverlay *tileOverlay 懒加载地图 pragma mark -----懒加载 // 定位管理者 - (AMapLocationManager *)locationManager { if (_locationManager == nil) { AMapLocationManager *locationManager = [[AMapLocationManager alloc] init]; locationManager.delegate = self; // 定位的最小更新距离 locationManager.distanceFilter = 50; // 指定定位是否会被系统自动暂停。默认为NO。 locationManager.pausesLocationUpdatesAutomatically = NO; // 是否允许后台定位。默认为NO。 locationManager.allowsBackgroundLocationUpdates = YES; // 连续定位是否返回逆地理信息，默认NO。 locationManager.locatingWithReGeocode = YES; locationManager.desiredAccuracy = 10; _locationManager = locationManager; } return _locationManager; } // MapView -(MAMapView *)mapView{ if (!_mapView) { // 1、地图 MAMapView *mapView = [[MAMapView alloc] initWithFrame:self.view.bounds]; mapView.delegate = self; // 是否显示用户位置（定位蓝点） mapView.showsUserLocation = YES; mapView.userTrackingMode = MAUserTrackingModeFollow; // 是否显示室内地图, 默认NO mapView.showsIndoorMap = YES; // 地图类型 mapView.mapType = MAMapTypeStandard; // 地图logo（高德地图字样） // mapView.logoCenter // 指南针 mapView.showsCompass = NO; mapView.compassOrigin = CGPointMake(kScreenWidth, 200); // 比例尺 mapView.showsScale= YES; //设置成NO表示不显示比例尺；YES表示显示比例尺 if (kIsIphoneX) { mapView.scaleOrigin= CGPointMake(_mapView.scaleOrigin.x,kScreenHeight-300); //设置比例尺位置 }else{ mapView.scaleOrigin= CGPointMake(_mapView.scaleOrigin.x,kScreenHeight-53); //设置比例尺位置 } // 是否支持缩放, 默认YES mapView.zoomEnabled = YES; // 缩放级别（默认3-19，有室内地图时为3-20） mapView.zoomLevel = 17; mapView.minZoomLevel = kTileOverlayRemoteMinZoom; mapView.maxZoomLevel = kTileOverlayRemoteMaxZoom; // 是否支持平移, 默认YES mapView.scrollEnabled = YES; // 是否支持旋转, 默认YES mapView.rotateEnabled = YES; // 是否支持倾斜, 默认YES（用户可以在地图上放置两个手指，移动它们一起向下或向上去增加或减小倾斜角。） mapView.rotateCameraEnabled = YES; _mapView = mapView; } _mapView.delegate = self; return _mapView; } 然后将将地图添加到View上 // 高德地图 [self.view addSubview:self.mapView]; // 开启持续定位 [self.locationManager startUpdatingLocation]; 这里因为要实时绘制行走的路线轨迹，所以使用持续定位，到这里，地图已经显示出来了 使用高德地图加载谷歌地图瓦片（地形图和卫星图）设置默认 地图 // Google地形瓦片地图URL define kTileOverlayGoogleTopography @\"http://mt2.google.cn/vt/lyrs=p&amp;scale=2&amp;hl=zh-CN&amp;gl=cn&amp;x={x}&amp;y={y}&amp;z={z}\" // Google卫星瓦片地图URL define kTileOverlayGoogleSatellite @\"http://mt2.google.cn/vt/lyrs=y&amp;scale=2&amp;hl=zh-CN&amp;gl=cn&amp;x={x}&amp;y={y}&amp;z={z}\" // 瓦片最小缩放级别 define kTileOverlayRemoteMinZoom 3 // 瓦片最大缩放级别 define kTileOverlayRemoteMaxZoom 19 pragma mark - 构建Google瓦片 - (MATileOverlay *)constructGoogleTileOverlay:(NSString *)url { MATileOverlay *tileOverlay = [[MATileOverlay alloc] initWithURLTemplate:url]; tileOverlay.minimumZ = kTileOverlayRemoteMinZoom; tileOverlay.maximumZ = kTileOverlayRemoteMaxZoom; tileOverlay.boundingMapRect = MAMapRectWorld; return tileOverlay; } /** * @brief 根据overlay生成对应的Renderer * @param mapView 地图View * @param overlay 指定的overlay * @return 生成的覆盖物Renderer */ - (MAOverlayRenderer *)mapView:(MAMapView *)mapView rendererForOverlay:(id&lt;MAOverlay>)overlay { if ([overlay isKindOfClass:[MATileOverlay class]]) { // 瓦片 MATileOverlayRenderer *render = [[MATileOverlayRenderer alloc] initWithTileOverlay:overlay]; return render; } return nil; } - (void)setMapStyp{ NSInteger mapType = [[NSUserDefaults standardUserDefaults] integerForKey:@\"mapType\"]; if (mapType == 0) { [self.mapView removeOverlays:self.mapView.overlays]; }else if (mapType == 1){ // 移除所有瓦片 [self.mapView removeOverlays:self.mapView.overlays]; // 构建Google地形瓦片 [self.mapView addOverlay:[self constructGoogleTileOverlay:kTileOverlayGoogleTopography]]; }else if (mapType == 2){ [self.mapView removeOverlays:self.mapView.overlays]; // 构建Google卫星瓦片 [self.mapView addOverlay:[self constructGoogleTileOverlay:kTileOverlayGoogleSatellite]]; } } 实时轨迹画线首先在地图的代理中，采集画轨迹所需要的坐标点 pragma mark - 位置更新之后 - (void)amapLocationManager:(AMapLocationManager *)manager didUpdateLocation:(CLLocation *)location reGeocode:(AMapLocationReGeocode *)reGeocode { // 底部显示坐标 self.locationLabel.text = [NSString stringWithFormat:@\"%lf %lf\",location.coordinate.longitude,location.coordinate.latitude]; // 底部显示的海拔 self.altitudeLabel.text = [NSString stringWithFormat:@\"%.fM\",location.altitude]; // 如果点了暂停，不在往数组里添加点 if (self.isPause) return; // 如果还在初始化中，不在往数组里添加点 if (self.showSetUpView) return; if (self.locationMutableArray.count>0) { // 从位置数组中取出最后一个点的位置 NSMutableDictionary *getPointDict = self.locationMutableArray.lastObject; // 计算当前位置和上一个点之间的时间间隔 NSString *fromDateStr = getPointDict[@\"time\"]; NSString *toDateStr = [self.dateFormatter stringFromDate:location.timestamp]; NSInteger secondsInterval = [self caculateDateWithFromDateStr:fromDateStr toDateStr:toDateStr]; // 如果时间间隔小于2秒，不记录 if (secondsInterval&lt;1) return; // 计算当前位置和上一个点之间的距离 NSString *latitudeStr = getPointDict[@\"latitude\"]; NSString *longitudeStr = getPointDict[@\"longitude\"]; // 拿到当前位置数据 CLLocationCoordinate2D endCoordinate; endCoordinate.latitude = location.coordinate.latitude; endCoordinate.longitude = location.coordinate.longitude; double meters = [self distanceBetweenOrderBy:latitudeStr.doubleValue :location.coordinate.latitude :longitudeStr.doubleValue :location.coordinate.longitude]; // 大于所少米可以记录 if (self.travalType != 3) { if (meters&lt;self.travalTypeM) return; } // 速度大于200公里/时 if ((meters/secondsInterval)>55.555) return; // 计算行走的米数 [self caculateTrackDistanceWithUserLocation:location]; // 将点数据添加到数组中 NSString *pointDate = [self.dateFormatter stringFromDate:location.timestamp]; NSMutableDictionary *pointDict = [NSMutableDictionary dictionary]; pointDict[@\"longitude\"] = [NSString stringWithFormat:@\"%f\",location.coordinate.longitude]; pointDict[@\"latitude\"] = [NSString stringWithFormat:@\"%f\",location.coordinate.latitude]; pointDict[@\"altitude\"] = [NSString stringWithFormat:@\"%.f\",location.altitude]; pointDict[@\"time\"] = pointDate; [self.locationMutableArray addObject:pointDict]; NSString *altitude = [NSString stringWithFormat:@\"%.f\",location.altitude]; [self.altitudeArray addObject:altitude]; // 画线 [self drawLine]; }else{ // 将点数据添加到数组中 NSString *pointDate = [self.dateFormatter stringFromDate:location.timestamp]; NSMutableDictionary *pointDict = [NSMutableDictionary dictionary]; pointDict[@\"longitude\"] = [NSString stringWithFormat:@\"%f\",location.coordinate.longitude]; pointDict[@\"latitude\"] = [NSString stringWithFormat:@\"%f\",location.coordinate.latitude]; pointDict[@\"altitude\"] = [NSString stringWithFormat:@\"%.f\",location.altitude]; pointDict[@\"time\"] = pointDate; [self.locationMutableArray addObject:pointDict]; // 添加起点坐标View self.startAnnotation.coordinate = location.coordinate; [self.mapView addAnnotation:self.startAnnotation]; } } /// 画线 - (void)drawLine{ // 先移除 [self.mapView removeOverlay:self.smoothedTrace]; MASmoothPathTool *tool = [[MASmoothPathTool alloc] init]; tool.intensity = 4; tool.threshHold = 0.25; tool.noiseThreshhold = 10; NSMutableArray *tempArray = [NSMutableArray array]; /// 将自己的点Model转换成MALonLatPoint for (NSMutableDictionary *pointDict in self.locationMutableArray) { MALonLatPoint *smoothPoint = [[MALonLatPoint alloc]init]; smoothPoint.lat = [pointDict[@\"latitude\"] floatValue]; smoothPoint.lon = [pointDict[@\"longitude\"] floatValue]; [tempArray addObject:smoothPoint]; } // 平滑处理之后的坐标点 NSArray *smoothedTraceArray = [tool pathOptimize:tempArray]; CLLocationCoordinate2D *pCoords = malloc(sizeof(CLLocationCoordinate2D) * smoothedTraceArray.count); if(!pCoords) { return; } for(int i = 0; i &lt; smoothedTraceArray.count; ++i) { MALonLatPoint *p = [smoothedTraceArray objectAtIndex:i]; CLLocationCoordinate2D *pCur = pCoords + i; pCur->latitude = p.lat; pCur->longitude = p.lon; } self.smoothedTrace = [MAPolyline polylineWithCoordinates:pCoords count:tempArray.count]; [self.mapView addOverlay:self.smoothedTrace]; if(pCoords) { free(pCoords); } } // 计算两个日期的差值 - (NSInteger)caculateDateWithFromDateStr:(NSString*)fromDateStr toDateStr:(NSString*)toDateStr{ NSDate *fromDate = [self.dateFormatter dateFromString:fromDateStr]; NSDate *toDate = [self.dateFormatter dateFromString:toDateStr]; // 创建日历类 NSCalendar *calendar = [NSCalendar currentCalendar]; // 设置比较的级别：秒 NSCalendarUnit unit = NSCalendarUnitSecond; //比较的结果是NSDateComponents类对象 NSDateComponents *delta = [calendar components:unit fromDate:fromDate toDate:toDate options:0]; return delta.second; } /// 计算两个经纬度之间的距离 -(double)distanceBetweenOrderBy:(double) lat1 :(double) lat2 :(double) lng1 :(double) lng2{ CLLocation *curLocation = [[CLLocation alloc] initWithLatitude:lat1 longitude:lng1]; CLLocation *otherLocation = [[CLLocation alloc] initWithLatitude:lat2 longitude:lng2]; double distance = [curLocation distanceFromLocation:otherLocation]; return distance; } 这里计算时间间隔和两个坐标点之间的距离，是为了过滤一些其他不必要的点，iOS采集坐标点跟安卓不一致，是在位置更新之后，会频繁的给出很多坐标点，并没有什么规律，这样还可以优化坐标点飘点的问题，因为高德在iOS上采用的是混合定位，采集方式不可修改，所以只能通过其他的方式去做筛选。尽可能的将异常的点排除掉。 在地图上添加自定义的大头针，以及标注图/// 自定义用户位置样式 - (MAAnnotationView *)mapView:(MAMapView *)mapView viewForAnnotation:(id&lt;MAAnnotation>)annotation { /* 自定义userLocation对应的annotationView. */ if ([annotation isKindOfClass:[MAUserLocation class]]) { static NSString *userLocationStyleReuseIndetifier = @\"userLocationStyleReuseIndetifier\"; MAAnnotationView *annotationView = [mapView dequeueReusableAnnotationViewWithIdentifier:userLocationStyleReuseIndetifier]; if (annotationView == nil){ annotationView = [[LocationAnnotationView alloc] initWithAnnotation:annotation reuseIdentifier:userLocationStyleReuseIndetifier]; annotationView.canShowCallout = YES; } _locationAnnotationView = (LocationAnnotationView *)annotationView; [_locationAnnotationView updateImage:[UIImage imageNamed:@\"userPosition\"]]; return annotationView; } if ([annotation isKindOfClass:[MAPointAnnotation class]]){ static NSString *customReuseIndetifier = @\"customReuseIndetifier\"; FYCustomAnnotationView *annotationView = (FYCustomAnnotationView*)[mapView dequeueReusableAnnotationViewWithIdentifier:customReuseIndetifier]; if (annotationView == nil){ annotationView = [[FYCustomAnnotationView alloc] initWithAnnotation:annotation reuseIdentifier:customReuseIndetifier]; annotationView.canShowCallout = NO; annotationView.draggable = YES; annotationView.calloutOffset = CGPointMake(0, -5); } __weak typeof(annotationView) weakAnnotationView = annotationView; annotationView.clickImage = ^{ }; annotationView.delegate = self; if (annotation == self.startAnnotation||annotation == self.trackStartAnnotation) { annotationView.image = [UIImage imageNamed:@\"qi\"]; }else if (annotation == self.trackEndAnnotation){ annotationView.image = [UIImage imageNamed:@\"zhong\"]; }else{ annotationView.image = [UIImage imageNamed:@\"paizhaodian\"]; } return annotationView; } return nil; } 在设置自定义的标注图的时候首先要继承MAAnnotationView在.h文件中 #import &lt;MAMapKit/MAMapKit.h> #import \"FYCustomCalloutView.h\" NS_ASSUME_NONNULL_BEGIN @class FYCustomAnnotationView; @protocol FYCustomAnnotationViewDelegate &lt;NSObject> - (void)didClickDeleteAnnotationViewWith:(FYCustomAnnotationView*)annotationView; @end @interface FYCustomAnnotationView : MAAnnotationView @property (nonatomic, strong) FYCustomCalloutView *calloutView; @property (nonatomic, copy) void(^clickImage)(void); @property (nonatomic, copy) void(^clickDeleteImageAction)(void); @property (nonatomic, weak) id&lt;FYCustomAnnotationViewDelegate>delegate; @end NS_ASSUME_NONNULL_END 在.m文件中 #import \"FYCustomAnnotationView.h\" @implementation FYCustomAnnotationView - (void)setSelected:(BOOL)selected animated:(BOOL)animated{ if (self.selected == selected){ return; } if (selected){ if (self.calloutView == nil){ self.calloutView = [FYCustomCalloutView viewFromXib]; self.calloutView.alpha = 0; self.calloutView.frame = CGRectMake(0, 0, 100, 105); self.calloutView.center = CGPointMake(CGRectGetWidth(self.bounds) / 2.f + self.calloutOffset.x, -CGRectGetHeight(self.calloutView.bounds) / 2.f + self.calloutOffset.y); self.calloutView.userInteractionEnabled = YES; self.calloutView.photoImgView.userInteractionEnabled = YES; } [self addSubview:self.calloutView]; [UIView animateWithDuration:0.3 animations:^{ self.calloutView.alpha = 1; }]; }else{ [self.calloutView removeFromSuperview]; } [super setSelected:selected animated:animated]; } /** 重写这个方法，可以让整个在父控件之外的气泡点击也有反应； */ - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event { // 如果一个子视图的区域超出父视图的bounds，那么正常情况下对子视图在父视图之外区域的触摸操作是不会被识别的，因为父视图的pointInside:withEvent:方法会返回NO，这样的话就不会继续向下遍历子视图了； // 返回一个view来响应事件 CGPoint point0 = [self convertPoint:point toView:self.calloutView.deleteButton]; if ([self.calloutView.deleteButton pointInside:point0 withEvent:event]) { if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(didClickDeleteAnnotationViewWith:)]) { [self.delegate didClickDeleteAnnotationViewWith:self]; } return self.calloutView.deleteButton; } CGPoint newPoint = [self convertPoint:point toView:self.calloutView]; if ([self.calloutView pointInside:newPoint withEvent:event]) { if (self.clickImage) { self.clickImage(); } return self.calloutView; } return [super hitTest:point withEvent:event]; } @end 标注图calloutView.h文件中 @interface FYCustomCalloutView : UIView @property (weak, nonatomic) IBOutlet UIImageView *photoImgView; @property (weak, nonatomic) IBOutlet UIButton *deleteButton; @end .m文件中不需要做其他的设置，然后添加坐标点就可以了 // 初始化地图上的照片 MAPointAnnotation *pointAnnotation = [[MAPointAnnotation alloc] init]; // 创建位置数据 CLLocationCoordinate2D coordinate = CLLocationCoordinate2DMake([imageModel[@\"startLatitude\"] floatValue],[imageModel[@\"startLongitude\"] floatValue]); pointAnnotation.coordinate = coordinate; // 添加到地图上 [self.mapView addAnnotation:pointAnnotation]; 这样就可以添加了，另外添加起点和终点也是同样","categories":[{"name":"iOS基础知识总结","slug":"iOS基础知识总结","permalink":"https://jackerchongchong.github.io/categories/iOS基础知识总结/"}],"tags":[{"name":"iOS基础知识总结","slug":"iOS基础知识总结","permalink":"https://jackerchongchong.github.io/tags/iOS基础知识总结/"}]},{"title":"提高Xcode编译速度","slug":"macBase1","date":"2019-11-26T03:30:41.000Z","updated":"2019-11-26T06:02:15.570Z","comments":true,"path":"2019/11/26/macbase1/","link":"","permalink":"https://jackerchongchong.github.io/2019/11/26/macbase1/","excerpt":"","text":"提高Xcode编译速度最近在做公司项目的时候，由于工程比较大，引入的第三方比较多，所以项目编译速度很慢，就想办法优化。总结出几条建议，这里做一下记录，希望对大家有用。整体方法大致分为以下几种，如有不对的地方，敬请提出，欢迎指正。 第一、通过CCache大幅提高编译速度（本人也是这样解决的）我也是借鉴别人的经验，尝试了很多的方法，但是这个方法最有效，起码节省了50%以上的编译时间（这个都有点保守了），废话不多说，直接上步骤 安装之前，首先你的电脑上需要安装：Homebrew安装Homebrew自行百度，安装过程中会安装Xcode的一个工具，保证磁盘空间足够，等待客户端安装完成 运行代码 $ brew install ccache cd到项目目录，执行以下命令新建一个文件命名为 ccache-clang 的空白文件。 $ touch ccache-clang 找到这个ccache-clang文件，输入下面的脚本并保存 #!/bin/sh if type -p ccache >/dev/null 2>&amp;1; then export CCACHE_MAXSIZE=10G export CCACHE_CPP2=true export CCACHE_HARDLINK=true export CCACHE_SLOPPINESS=file_macro,time_macros,include_file_mtime,include_file_ctime,file_stat_matches # 指定日志文件路径到桌面，等下排查集成问题有用，集成成功后删除，否则很占磁盘空间 export CCACHE_LOGFILE='~/Desktop/CCache.log' exec ccache /usr/bin/clang \"$@\" else exec clang \"$@\" fi 为了保证cocoaPods的正常使用，按照上面的命令再创建一个文件命名为 ccache-clang++ 的空白文件 #!/bin/sh if type -p ccache >/dev/null 2>&amp;1; then export CCACHE_MAXSIZE=10G export CCACHE_CPP2=true export CCACHE_HARDLINK=true export CCACHE_SLOPPINESS=file_macro,time_macros,include_file_mtime,include_file_ctime,file_stat_matches # 指定日志文件路径到桌面，等下排查集成问题有用，集成成功后删除，否则很占磁盘空间 export CCACHE_LOGFILE='~/Desktop/CCache.log' exec ccache /usr/bin/clang++ \"$@\" else exec clang++ \"$@\" fi 在命令行中， ccache-clang 文件的目录，把它的权限改成可执行文件 $ chmod 777 ccache-clang $ chmod 777 ccache-clang++ 然后在Xcode项目中增加一个CC常量 在你项目的构建设置(Build Settings)中，添加一个常量CC，这个值会让 Xcode 在编译时把执行路径的可执行文件当做 C 编译器。CC常量的值为 $(SRCROOT)/ccache-clang，如果你的脚本不是放在项目根目录，则自行调整路径。如果一运行项目就报错，检查下路径是不是填错了。 简单来说，这一步算是大功告成了，可以尝试一下，编译速度飞起 第二、注意自己的代码编写习惯这一条也很重要，就是在项目中的.h中，自定义的类，尽量使用@class name 这样在项目编译期间，知道这个类，然后在.m文件中再import 我也尝试了其他几种方法，一个是开启Xcode的线程数量，还有将Index索引这一步去掉，以及关闭执行日志，感觉都不是很好，希望这个方法对大家有帮助","categories":[{"name":"Mac使用","slug":"Mac使用","permalink":"https://jackerchongchong.github.io/categories/Mac使用/"}],"tags":[{"name":"Mac使用","slug":"Mac使用","permalink":"https://jackerchongchong.github.io/tags/Mac使用/"}]},{"title":"AFN表单上传图片","slug":"iOSBase3","date":"2019-08-26T06:41:58.000Z","updated":"2019-08-26T07:35:01.000Z","comments":true,"path":"2019/08/26/iosbase3/","link":"","permalink":"https://jackerchongchong.github.io/2019/08/26/iosbase3/","excerpt":"","text":"AFN表单上传图片今天在做项目上传图片的时候，用到了formData上传图片，遇到了问题，很奇怪的问题。需求是这样的：上传图片，首先压缩一定的比例，然后转成base64格式的data，传给后台参数是这样的：img_base64:imageData 在postMan中的请求是这样的： 在代码中，我们需要这样做，图片转码代码如下： // 压缩图片质量 NSData *data = UIImageJPEGRepresentation(img, 0.5); // 图片转码 NSData *dataImg = [data base64EncodedDataWithOptions:NSDataBase64Encoding64CharacterLineLength]; 算了，直接撸代码 // 1、创建请求管理者 AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager]; mgr.responseSerializer = [AFHTTPResponseSerializer serializer]; mgr.requestSerializer = [AFHTTPRequestSerializer serializer]; AFSecurityPolicy *securityPolicy = [[AFSecurityPolicy alloc] init]; [securityPolicy setAllowInvalidCertificates:YES]; [mgr setSecurityPolicy:securityPolicy]; [mgr.requestSerializer setValue:@\"application/x-www-form-urlencoded; charset=utf-8\" forHTTPHeaderField:@\"Content-Type\"]; [mgr.requestSerializer willChangeValueForKey:@\"timeoutInterval\"]; mgr.requestSerializer.timeoutInterval = 15.0f; // 默认超时时长为60s [mgr.requestSerializer didChangeValueForKey:@\"timeoutInterval\"]; mgr.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@\"text/plain\", @\"multipart/form-data\", @\"application/json\", @\"text/html\", @\"image/jpeg\", @\"image/png\", @\"application/octet-stream\", @\"text/json\", nil]; [mgr POST:URL parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData> _Nonnull formData) { // 参数名：img_base64 ：dataImg [formData appendPartWithFormData:dataImg name:@\"img_base64\"]; } progress:^(NSProgress * _Nonnull uploadProgress) { } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:responseObject options:0 error:nil]; self.responseObj = dict; } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { [mgr.operationQueue cancelAllOperations]; SHOWERROR(@\"识别失败\"); }]; 注意：在iOS转成base64的data的时候，是不带data:image/png;base64,这个头的，但是安卓在进行这些的时候是有的，所以需要跟后台商量好，踩坑了，以此谨记!在AFN中还有另一种拼接方式，也是很常见的上传拼接方式 第二种方式 /** POST请求（接收JSON格式数据） @param URLString 请求的URL @param parameters 请求的参数 @param photos 上传图片数组 @param success 请求成功的回调 @param failure 请求失败的回调 */ - (void)POST:(NSString *)URLString parameters:(id)parameters photos:(NSArray *)photos success:(void (^)(id responseObject)) success failure:(void(^)(NSError *error)) failure { // 1、创建请求管理者 AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager]; mgr.responseSerializer = [AFHTTPResponseSerializer serializer]; mgr.requestSerializer = [AFHTTPRequestSerializer serializer]; AFSecurityPolicy *securityPolicy = [[AFSecurityPolicy alloc] init]; [securityPolicy setAllowInvalidCertificates:YES]; [mgr setSecurityPolicy:securityPolicy]; [mgr.requestSerializer setValue:@\"application/x-www-form-urlencoded; charset=utf-8\" forHTTPHeaderField:@\"Content-Type\"]; [mgr.requestSerializer willChangeValueForKey:@\"timeoutInterval\"]; mgr.requestSerializer.timeoutInterval = 15.0f; // 默认超时时长为60s [mgr.requestSerializer didChangeValueForKey:@\"timeoutInterval\"]; mgr.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@\"application/json\", @\"text/json\", @\"text/javascript\", @\"text/html\", @\"text/plain\", nil]; [mgr POST:URLString parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData> _Nonnull formData) { // formData: 专门用于拼接需要上传的数据,在此位置生成一个要上传的数据体 // 这里的_photoArr是你存放图片的数组 // formData: 专门用于拼接需要上传的数据,在此位置生成一个要上传的数据体 // 这里的_photoArr是你存放图片的数组 for (int i = 0; i &lt; photos.count; i++) { UIImage *image = photos[i]; //QFLog(@\"+++++%@\",image); NSData *imageData = UIImagePNGRepresentation(image); // 在网络开发中，上传文件时，是文件不允许被覆盖，文件重名 // 要解决此问题， // 可以在上传时使用当前的系统事件作为文件名 NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; // 设置时间格式 [formatter setDateFormat:@\"yyyyMMddHHmmss\"]; NSString *dateString = [formatter stringFromDate:[NSDate date]]; NSString *fileName = [NSString stringWithFormat:@\"%@%ld.png\", dateString,(NSInteger)i]; /* *该方法的参数 1. appendPartWithFileData：要上传的照片[二进制流] 2. name：对应网站上[upload.php中]处理文件的字段（比如upload） 3. fileName：要保存在服务器上的文件名 4. mimeType：上传的文件的类型 */ [formData appendPartWithFileData:imageData name:@\"file\" fileName:fileName mimeType:@\"application/octet-stream\"]; // } } progress:^(NSProgress * _Nonnull uploadProgress) { } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { if (success) { success(responseObject); } [mgr.operationQueue cancelAllOperations]; } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { if (failure) { failure(error); } [mgr.operationQueue cancelAllOperations]; }]; } 系统方式如果不用AFN的话，用系统的方法，就有点麻烦了，这里是系统的方法： #pragma mark ------系统上传 - (void)uploadHeadImage:(UIImage *)image onSuccess:(void (^)(NSDictionary *dict))onSuccess onFailure:(void(^)(NSError *error))onFailure { //BaseWebAddr：服务器地址 NSString *urlStr = @\"http://47.104.193.88:8080/plant/recognize\"; NSURL *url = [NSURL URLWithString:urlStr]; //在此声明一个字符串常量,代替下面的 BOUNDARY 字符串 // NSString * const POST_BOUNDS = @\"----iOSKitFormBoundarycIO0B6mmsXU6koBg\"; NSData *imageData; NSString *imageFormat; if (UIImagePNGRepresentation(image) != nil) { imageFormat = @\"Content-Type: image/png \\r\\n\"; imageData = UIImagePNGRepresentation(image); imageData = [imageData base64EncodedDataWithOptions:NSDataBase64Encoding64CharacterLineLength]; }else{ imageFormat = @\"Content-Type: image/jpeg \\r\\n\"; imageData = UIImageJPEGRepresentation(image, 1.0); imageData = [imageData base64EncodedDataWithOptions:NSDataBase64Encoding64CharacterLineLength]; } NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; request.HTTPMethod = @\"POST\"; //设置请求实体 NSMutableData *body = [NSMutableData data]; ///文件参数 [body appendData:[self getDataWithString:@\"--BOUNDARY\\r\\n\" ]]; NSString *disposition = [NSString stringWithFormat:@\"Content-Disposition: form-data; name=\\\"%@\\\"; filename=\\\"pppp.jpg\\\"\\r\\n\",@\"img_base64\"]; [body appendData:[self getDataWithString:disposition]]; [body appendData:[self getDataWithString:imageFormat]]; [body appendData:[self getDataWithString:@\"\\r\\n\"]]; [body appendData:imageData]; [body appendData:[self getDataWithString:@\"\\r\\n\"]]; //普通参数 [body appendData:[self getDataWithString:@\"--BOUNDARY\\r\\n\" ]]; //上传参数需要key NSString *dispositions = [NSString stringWithFormat:@\"Content-Disposition: form-data; name=\\\"%@\\\"\\r\\n\",@\"uid\"]; [body appendData:[self getDataWithString:dispositions]]; [body appendData:[self getDataWithString:@\"\\r\\n\"]]; [body appendData:[self getDataWithString:@\"\\r\\n\"]]; //参数结束 [body appendData:[self getDataWithString:@\"--BOUNDARY--\\r\\n\"]]; request.HTTPBody = body; //设置请求体长度 NSInteger length = [body length]; [request setValue:[NSString stringWithFormat:@\"%ld\",length] forHTTPHeaderField:@\"Content-Length\"]; //设置 POST请求文件上传 [request setValue:@\"multipart/form-data; boundary=BOUNDARY\" forHTTPHeaderField:@\"Content-Type\"]; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { NSJSONSerialization *object = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil]; NSDictionary *dict = (NSDictionary *)object; NSLog(@\"=====%@\",[dict objectForKey:@\"success\"]); }]; //开始任务 [dataTask resume]; } -(NSData *)getDataWithString:(NSString *)string{ NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding]; return data; } 这里的参数是img_base64:imageData uid:uid本人也是在踩坑的路上不断前进，希望对大家有用","categories":[{"name":"AFN表单上传图片","slug":"AFN表单上传图片","permalink":"https://jackerchongchong.github.io/categories/AFN表单上传图片/"}],"tags":[{"name":"AFN表单上传图片","slug":"AFN表单上传图片","permalink":"https://jackerchongchong.github.io/tags/AFN表单上传图片/"}]},{"title":"修改UITextField的placeHolder文字颜色的三种方法","slug":"iOSBase2","date":"2019-08-21T03:11:55.000Z","updated":"2019-08-21T03:31:36.000Z","comments":true,"path":"2019/08/21/iosbase2/","link":"","permalink":"https://jackerchongchong.github.io/2019/08/21/iosbase2/","excerpt":"","text":"修改TextField的占位文字的三种方法第一种 ：通过TextField的attributedPlaceholder属性修改占位文字颜色例如： NSAttributedString *attr = [[NSAttributedString alloc]initWithString:@\"搜索位置\"attributes:@{NSForegroundColorAttributeName:[[UIColor whiteColor]}]; self.searchTextField.attributedPlaceholder = attr; 第二种 ：通过继承UItextfield，然后重写-(void)drawPlaceholderInRect:(CGRect)rect方法修改例如： // 修改占位文字颜色 -(void)drawPlaceholderInRect:(CGRect)rect { // 计算占位文字的 Size CGSize placeholderSize = [self.placeholder sizeWithAttributes: @{NSFontAttributeName : self.font}]; CGRect drawRect = CGRectMake(0, (rect.size.height - placeholderSize.height)/2, rect.size.width, rect.size.height); NSDictionary *attributes = @{NSForegroundColorAttributeName:[[UIColor whiteColor] colorWithAlphaComponent:0.8],NSFontAttributeName : self.font}; [self.placeholder drawInRect:drawRect withAttributes:attributes]; } 第三种 ：通过KVC的方式// 'self'指的是UITextfield [self setValue:[[UIColor whiteColor] colorWithAlphaComponent:0.8] forKeyPath:@\"_placeholderLabel.textColor\"]; 通过KVC的方式有一定风险，如果系统更新，官方文档中修改了一些控件的属性名称，则会导致程序崩溃","categories":[{"name":"iOS基础知识总结","slug":"iOS基础知识总结","permalink":"https://jackerchongchong.github.io/categories/iOS基础知识总结/"}],"tags":[{"name":"iOS基础知识总结","slug":"iOS基础知识总结","permalink":"https://jackerchongchong.github.io/tags/iOS基础知识总结/"}]},{"title":"打开Mac电脑任何来源的方法","slug":"macBase0","date":"2019-08-16T02:08:25.000Z","updated":"2019-08-16T02:22:55.000Z","comments":true,"path":"2019/08/16/macbase0/","link":"","permalink":"https://jackerchongchong.github.io/2019/08/16/macbase0/","excerpt":"","text":"打开Mac电脑任何来源的方法Mac 升级到10.12.4后，一些网络下载的软件打开提示，该文件已损坏。以前在 偏好设置-&gt;安全性设置 有“任何来源”，勾选即可，现在没有了这个选项。开启这个功能：打开Terminal，输入指令 sudo spctl –master-disable","categories":[{"name":"Mac使用","slug":"Mac使用","permalink":"https://jackerchongchong.github.io/categories/Mac使用/"}],"tags":[{"name":"Mac使用","slug":"Mac使用","permalink":"https://jackerchongchong.github.io/tags/Mac使用/"}]},{"title":"iOS点击按钮震动小效果","slug":"iOSBase1","date":"2019-08-14T03:32:32.000Z","updated":"2019-08-14T03:54:18.000Z","comments":true,"path":"2019/08/14/iosbase1/","link":"","permalink":"https://jackerchongchong.github.io/2019/08/14/iosbase1/","excerpt":"","text":"iOS震动反馈iOS 10之后，推出了震动反馈，比之前的震动效果好很多，现在在很多APP中的一些功能中会加入这个功能，让客户更明确自己的行为，比如在下拉刷新，在点击按钮获取验证码的时候，如果加上这个效果，会让用户体验更好一些。震动反馈会用到 UIFeedbackGenerator 点击进入这个类，这类里面是这样的。 #import &lt;UIKit/UIFeedbackGenerator.h> NS_ASSUME_NONNULL_BEGIN typedef NS_ENUM(NSInteger, UIImpactFeedbackStyle) { UIImpactFeedbackStyleLight, UIImpactFeedbackStyleMedium, UIImpactFeedbackStyleHeavy }; // UIImpactFeedbackGenerator is used to give user feedback when an impact between UI elements occurs UIKIT_CLASS_AVAILABLE_IOS_ONLY(10_0) @interface UIImpactFeedbackGenerator : UIFeedbackGenerator - (instancetype)initWithStyle:(UIImpactFeedbackStyle)style; /// call when your UI element impacts something else - (void)impactOccurred; @end NS_ASSUME_NONNULL_END #else #import &lt;UIKitCore/UIImpactFeedbackGenerator.h> #endif 调用方法也很简单： // 主线程 dispatch_async(dispatch_get_main_queue(), ^{ // 版本限制 if (@available(iOS 10.0, *)) { // 初始化震动反馈类 UIImpactFeedbackGenerator *generator = [[UIImpactFeedbackGenerator alloc] initWithStyle:UIImpactFeedbackStyleLight]; // 准备 [generator prepare]; // 调用 [generator impactOccurred]; } }); 只需要在比如按钮点击的时候调用这个方法即可，很不多的用户体验","categories":[{"name":"iOS基础知识总结","slug":"iOS基础知识总结","permalink":"https://jackerchongchong.github.io/categories/iOS基础知识总结/"}],"tags":[{"name":"iOS基础知识总结","slug":"iOS基础知识总结","permalink":"https://jackerchongchong.github.io/tags/iOS基础知识总结/"}]},{"title":"OC中的宏、static、const、宏","slug":"iosBase0","date":"2019-08-01T10:47:25.000Z","updated":"2019-08-08T13:11:29.000Z","comments":true,"path":"2019/08/01/iosbase0/","link":"","permalink":"https://jackerchongchong.github.io/2019/08/01/iosbase0/","excerpt":"","text":"OC中extern、static、const和宏的一些用法区别，和使用场景1、宏宏可以定义代码，用#define来声明。它可以定义一些常量，例如：1.定义字符串：#define kSessionId @&quot;kSessionId&quot;2.定义一些代码：#define GETTOKEN [[NSUserDefaults standardUserDefaults] stringForKey:KToken]3、可以做一些判断如: ＃define 定义一个预处理宏 ＃undef 取消宏的定义 ＃if 编译预处理中的条件命令， 相当于C语法中的if语句 ＃ifdef 判断某个宏是否被定义(＃define过)， 若已定义， 执行随后的语句 ＃ifndef 与＃ifdef相反， 判断某个宏是否未被定义 ＃elif 若＃if， ＃ifdef， ＃ifndef或前面的＃elif条件不满足， 则执行＃elif之后的语句， 相当于C语法中的else-if ＃else 与＃if， ＃ifdef， ＃ifndef对应， 若这些条件不满足， 则执行＃else之后的语句， 相当于C语法中的else ＃endif ＃if， ＃ifdef， ＃ifndef这些条件命令的结束标志. defined 与＃if， ＃elif配合使用， 判断某个宏是否被定义 ＃pragma 说明编译器信息 ＃warning 显示编译警告信息 ＃error 显示编译错误信息配置debug 1.在 &quot;Target &gt; Build Settings &gt; Preprocessor Macros &gt; Debug&quot; 设置&quot;DEBUG=1”。 2.之后在pch或工具类中就可以这么写了： #ifdef DEBUG （debug 模式下的配置） #else （release 模式下的配置） #endif 宏定义的一些常量和代码一般执行的是替换，宏会在编译期被加载，所以如果宏定义过多，会影响编译的时间，所以定义一些常量，不应该在宏定义中去定义这些全局变量。那么应该用什么去定义呢，这里用到了extern 2、extern如果要声明一个常量的字符串，例如声明一些接口地址、统一声明NSNotificationName等，用extern声明，使用：在一个类的.h中声明：extern NSString *const refeshProjectAndClouldWorkList;在.m文件中：NSString *const refeshProjectAndClouldWorkList = @&quot;refeshProjectAndClouldWorkList&quot;使用，引入这个文件即可，也可以在需要用的地方，重新声明一下extern工作原理：先会去当前文件下查找有没有对应全局变量，如果没有，才会去其他文件查找 3、static1、被static修饰局部变量，延长生命周期，跟整个应用程序有关，程序结束才会销毁，如下：在一个类的里面打印下面的方法，只要程序不销毁, a 的值就不会被销毁，会一直保持最后一次给 a 赋的值2、被 static 修饰局部变量，只会分配一次内存3、程序一运行就会给static修饰变量分配内存4、修饰全局变量，被static修饰全局变量，作用域会修改，也就是只能在当前文件下使用 4、const1.仅仅只是用来修饰右边的变量（基本变量，指针变量，对象变量)2.const修饰的变量只读,是(只读)变量 5、 extern 和const配合使用static与const组合：在每个文件都需要定义一份静态全局变量。 extern 与 const 组合:只需要定义一份全局变量，多个文件共享。 提示：开发中便于管理所有的全局变量，通常搞一个Global文件，里面专门定义全局变量，统一管理，要不然项目文件太多不好找 当我们在一个防止一个变量被修改的时候，我们在前面加上 const3、 extern 的高级使用 (模仿 YYKIT 的使用 ),其实它只是把苹果的宏拿过来改改名字，看起来很牛逼，我们也可以牛逼一下，如下： 苹果的定义：UIKIT_EXTERN NSString *const refeshProjectAndClouldWorkList 欢迎大家关注 https://jackerchongchong.github.io ，提出您宝贵的意见","categories":[{"name":"iOS基础知识总结","slug":"iOS基础知识总结","permalink":"https://jackerchongchong.github.io/categories/iOS基础知识总结/"}],"tags":[{"name":"iOS基础知识总结","slug":"iOS基础知识总结","permalink":"https://jackerchongchong.github.io/tags/iOS基础知识总结/"}]},{"title":"粘性布局","slug":"firstArticle","date":"2019-07-31T06:47:25.000Z","updated":"2019-08-09T03:55:56.000Z","comments":true,"path":"2019/07/31/firstarticle/","link":"","permalink":"https://jackerchongchong.github.io/2019/07/31/firstarticle/","excerpt":"","text":"粘性布局整体思路 手指移动,按钮跟着移动.按钮跟着手指移动.移动时底部有一个圆, 根据上面的大圆按钮拖动的距离,小圆的半径在变小.移动时中间有一块不规则的填充区域. 手指移动超出一定的范围,填充效果消失,当手指松开时.判断当前大圆距离与小圆之间的距离. 如果小于60就让大圆回来原来的位置.下次拖动时,同样具有填充效果. 如果大于60,手指松开时,播放一个动画.动画完成时, 删除动画按钮. 实现思路1、自定义大圆控件（UIButton）可以显示背景图片，和文字按钮定义的时候要在初始方法中,把它的基本属性设置好.在开始加载的时候设置.基本属性包括颜色,圆角,文字颜色,大小.实现代码： self.backgroundColor = [UIColor redColor]; self.layer.cornerRadius = self.bounds.size.width * 0.5; self.titleLabel.font = [UIFont systemFontOfSize:12]; [self setTitleColor:[UIColor whiteColor]forState:UIControlStateNormal]; 2、让大圆控件随着手指移动而移动添加手势.同样也是在初始化方法当中进行设置.注意不能根据形变修改大圆的位置，只能通过center，因为全程都需要用到中心点计算。tansform并没有修改center,它修改的是Frame.添加手势代码为: UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)]; [self addGestureRecognizer:pan]; 手势实现方法为: CGPoint transP = [pan translationInView:self]; CGPoint center = self.center; center.x += transP.x; center.y +=transP.y; self.center = center; // 注意要做复位,相对于上一次. [pan setTranslation:CGPointZero inView:self]; 3、在拖动的时候，添加一个小圆控件在原来大圆控件的位置在初始化方法中添加小圆注意:添加小圆时不能够直接添加在当前按钮上,因为按钮是可以移动的,如果直接添加在按钮,它会跟着按钮一起移动.所以以把小圆添加到按钮父控件当中.添加时注意,要把小圆添加到按钮底部.不然会把按钮给盖起来. UIView *smallCircle = [[UIView alloc] init]; smallCircle.frame = self.frame; smallCircle.layer.cornerRadius = self.layer.cornerRadius; smallCircle.backgroundColor = self.backgroundColor; self.smallCircle = smallCircle; [self.superview insertSubview:smallCircle belowSubview:self]; 当手指拖动大圆时,小圆的半径会根据拖动的距离进行减小.所以要计算出两个圆之间的距离.计算完毕后.让小圆的原始半径每次都减去一个距离比例.重新设置尺寸大小.和小圆的半径.计算两个圆之间距离是一个功能单独抽出来.方法为: - (CGFloat)distanceWithSmallCircle:(UIView *)smallView bigCircle:(UIView *)bigCircle{ // X轴的便宜量 CGFloat offsetX = bigCircle.center.x - smallView.center.x; // Y轴的便宜量 CGFloat offsetY = bigCircle.center.y - smallView.center.y; CGFloat distance = sqrt(offsetX * offsetX + offsetY * offsetY); return distance; } 在手指拖动方法计算两个圆之间的距离, 根据拖动的距离让小圆的半径增大减小.实现代码为:CGFloat distance = [self distanceWithSmallCircle:self.smallCircle bigCircle:self];取出小圆的半径,注意这里是取出小圆最初的宽度,由于每次拖动的时候都会去修改小圆的宽高.所以这里不能直接用小圆的宽度,这里用的是大圆的宽度,开始小圆和大圆的宽度是一样的.大圆在移动时,大圆的宽高没有发现变化,所以可以拿到大圆的宽高CGFloat smallR = self.bounds.size.width * 0.5;让小圆的半径每次减去一个距离比例smallR = smallR - distance / 10.0;每次移动时,重新设置小圆的宽高self.smallCircle.bounds = CGRectMake(0, 0, smallR * 2, smallR * 2);重新设置小圆的圆角self.smallCircle.layer.cornerRadius = smallR; 4、添加粘性效果中间的粘性效果其实就是一块填充区域.只要把这个填充区域的路径给求出来就行了.中间的路径通过确定6个点.把这些点连接出来就行.求点为: x1,y1分别是小圆的圆心 x2,y2分别是大圆的圆心 r1代表小圆的半径 r2代表大圆的半径 d是两个圆之间的距离 y轴的偏移量 / 两个圆之间的距离 cosθ = (y2 - y1) / d; x轴的偏移量 / 两个圆之间的距离 sinθ = (x2 - x1) / d; 已知一个角,一个斜边 角的邻边 = 斜边 * cosθ 角的对边 = 斜边 * sinθ CGPoint pointA = CGPointMake(x1 - r1 * cosθ, y1 + r1 * sinθ); CGPoint pointB = CGPointMake(x1 + r1 * cosθ, y1 - r1 * sinθ); CGPoint pointC = CGPointMake(x2 + r2 * cosθ, y2 - r2 * sinθ); CGPoint pointD = CGPointMake(x2 - r2 * cosθ, y2 + r2 * sinθ); CGPoint pointO = CGPointMake(pointA.x + d * 0.5 * sinθ, pointA.y + d * 0.5 * cosθ); CGPoint pointP = CGPointMake(pointB.x + d * 0.5 * sinθ, pointB.y + d * 0.5 * cosθ); 创建路径,把这些点连接到一起 UIBezierPath *path = [UIBezierPath bezierPath]; // AB [path moveToPoint:pointA]; [path addLineToPoint:pointB]; // BC(曲线) [path addQuadCurveToPoint:pointC controlPoint:pointP]; // CD [path addLineToPoint:pointD]; // DA(曲线) [path addQuadCurveToPoint:pointA controlPoint:pointO]; 以上是根据两个圆求出不规则的矩形求出路径后,要把路径填充起来.但是不能够直接给填充到当前的按钮之上.按钮是可以拖动的.绘制东西,当超出它的范围以外就不会再绘制.所以要把路径添加到按钮的父控件当中, 但是当前是一个路径,是不能够直接添加到父控件当中的.可能过形状图层添加.形状图层会根据一个路径生成一个形状.把这个形状添加到当前控件的图片父层就可以了.添加时需要注意:形状图层之有一个,所以不能够在手指拖动方法当中添加.由于当手指拖动的距离超过某个范围后,形状图片会被移除.下一次再去移动时, 还会有填充的路径.所以把创建形状图层搞成一个懒加载的形式,如果发现下一次被删除时,再重新创建.形式为: -(CAShapeLayer *)shap{ if (_shap == nil) { // 创建形状图层 CAShapeLayer *shap = [CAShapeLayer layer]; // 设置形状图层的填充颜色 shap.fillColor = [UIColor redColor].CGColor; self.shap = shap; // 把形状图层添加到当前按钮的父层当中. [self.superview.layer insertSublayer:shap atIndex:0]; _shap = shap; } return _shap; } 在手指移动方法当中,给形状图层赋值路径就可以了. 5.粘性业务逻辑处理在手指移动方法判断两个圆之间的距离, 如果发现两个圆之间的距离超过60时让底部的小圆隐藏.把路径移除当小圆显示的时候才绘制填充路径 if (self.smallCircle.hidden == NO) { UIBezierPath *path = [self pathWithSmallCircle:self.smallCircle bigCircle:self]; self.shap.path = path.CGPath; } 当两个圆之间的距离超过60时. if(distance > 60){ // 移除填充路径 [self.shap removeFromSuperlayer]; // 让底部的小圆隐匿 self.smallCircle.hidden = YES; } 6.手指停止拖动业务逻辑移动后手指松开时判断两个圆之间的距离,如果两个圆之间的距离小于60时,让大圆复位.小圆显示. 手指松开时,如果两个圆之间的距离大于60时.播放一个动画.动画播放完毕时.把当前按钮从父控件当中移除.播放一个动画.创建一个UIImageView,尺寸和当前按钮一样大.UIImageView *imageV = [[UIImageView alloc] initWithFrame:self.bounds];创建动画图片 NSMutableArray *imageArray = [NSMutableArray array]; for (int i = 0; i &lt; 8 ; i++) { NSString *imageName = [NSString stringWithFormat:@\"%d\",i+1]; UIImage *image = [UIImage imageNamed:imageName]; [imageArray addObject:image]; } 设置动画图片数组imageV.animationImages = imageArray;设置动画执行时长imageV.animationDuration = 1;开始动画[imageV startAnimating];把UIImageView添加到当前按钮上 [self addSubview:imageV]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ [self removeFromSuperview]; }); 注意: 在控制器加载完毕后,要取消Autoresizing转自动布局 不然会出现按钮回原位的情况. self.view.translatesAutoresizingMaskIntoConstraints = NO;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://jackerchongchong.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://jackerchongchong.github.io/tags/iOS/"}]}],"categories":[{"name":"iOS基础知识总结","slug":"iOS基础知识总结","permalink":"https://jackerchongchong.github.io/categories/iOS基础知识总结/"},{"name":"Mac使用","slug":"Mac使用","permalink":"https://jackerchongchong.github.io/categories/Mac使用/"},{"name":"AFN表单上传图片","slug":"AFN表单上传图片","permalink":"https://jackerchongchong.github.io/categories/AFN表单上传图片/"},{"name":"iOS","slug":"iOS","permalink":"https://jackerchongchong.github.io/categories/iOS/"}],"tags":[{"name":"iOS基础知识总结","slug":"iOS基础知识总结","permalink":"https://jackerchongchong.github.io/tags/iOS基础知识总结/"},{"name":"Mac使用","slug":"Mac使用","permalink":"https://jackerchongchong.github.io/tags/Mac使用/"},{"name":"AFN表单上传图片","slug":"AFN表单上传图片","permalink":"https://jackerchongchong.github.io/tags/AFN表单上传图片/"},{"name":"iOS","slug":"iOS","permalink":"https://jackerchongchong.github.io/tags/iOS/"}]}